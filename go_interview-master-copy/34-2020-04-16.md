### 一、http 和https ，http1.0、1.1、2.0的区别，https 加密过程
rpc  相较于传统api 调用的优点，如何设计实现一个rpc
- http和https相比性能差距有多大
- 理论上讲应该就多个加密解密的过程吧
- 这个过程就够了。。。太费 CPU 了
- ecc 会比 rsa 快吗，快多少？
- 时间是花在握手上还是加密解密上？
- 单台 Nginx HTTP 可以支撑几万连接，HTTPS 只能几千
再多 CPU 要爆
- 应该在加解密吧
握手http也有这个过程
- 再抛一个常问的，https是对称加密还是非对称加密
- 最初建立连接时，会进行两次非对称，一次对称，之后传输数据都是对称了
- 两次非对称 
1次是服务端加密
1次是客户端验签吧
- 1-1000倍，我不知道哪里看的数据
- 「 子杨: 「懒懒：
最初建立连接时，会进行两次非对称，一次对称，之后传输数据都是对称了」
两次非对称怎么解释 」
一次是ca 证书，数字签名验证，一次是传输对称加密
- 数字签名包含啥，以及验签流程是啥
- 数字证书里，有服务器公钥和数字签名，数字签名，是ca机构通过摘要算法，提取出公钥的摘要，然后用ca机构的私钥对摘要加密，生成数字签名
- tls1.3 和 tls1.2 啥区别
- 1.2三次握手，1.3一次
- 我不理解的就是，公钥干啥用的
- 公钥验签
私钥加密
- 告诉和你通信的另一方之后发消息用公钥加密后再发
这块儿就是客户端拿到服务端的公钥好，验证通过了，将对称加密用的密码串用这个公钥加密后告诉服务器
- 并不一定必须通过CA
- 公钥加密 私钥解密
- 前几天我还做了一个
- 私钥加签 公钥验签
- 但是怎么验证没搞懂
- 自己生成一对，进行加解密你就知道了 
- 我觉得不是这样，ECDH 算法并不需要传递对称加密的秘钥，因为这个算法保证了双方生成的秘钥一定相同，所以我觉得应该是加密 ECDH 算法所需要的参数
- 自签名证书 别人浏览器或者操作系统没有权威CA机构颁发的生疏，浏览器就默认拒绝加载 
@牛晓东 看看pki 和 CA原理 
- 我去搜搜这个ECDH
- 「 子杨: 「懒懒：
这块儿就是客户端拿到服务端的公钥好，验证通过了，将对称加密用的密码串用这个公钥加密后告诉服务器」
我觉得不是这样，ECDH 算法并不需要传递对称加密的秘钥，因为这个算法保证了双方生成的秘钥一定相同，所以我觉得应该是加密 ECDH 算法所需要的参数 」
对称加密的秘钥不是直接传的，而是在之前的握手过程中双方拿到了相关参数，然后双方各自生成的。 这样讲对吗？
- 是说那个密码串是个参数是吗？
[https://time.geekbang.org/column/article/644b842ad2661608bd05b071e9dc55b1/share?code=SPwAUY1BgfghtU7s6iiIoxVchKtu2XVGCy2kEIeJP%2F4%3D](https://time.geekbang.org/column/article/644b842ad2661608bd05b071e9dc55b1/share?code=SPwAUY1BgfghtU7s6iiIoxVchKtu2XVGCy2kEIeJP%2F4%3D)
- 随机生成器的吧 共享密码串 还有时效呢 我记得根据RSA参数随机生成的一个共享密码串 然后后续用这个密码串进行对称加密 
- 所以我始终没搞明白数字证书里面的公钥是干啥的，如果要用来加密的话加密哪个东西。
- 验证证书的签名
- 证书里的公钥 是用来验证网站身份的；那怎样证明这个证书是真的？  用Ca的公钥验证 证书签名
- 对称密钥是  客户端 和 服务端 分别通过三个随机数算出来的，且双方算出来的对称密钥是一样的
前两个随机数是明文传给对方的 ，第三个随机数的生成方式  会根据选择的密码套件  而略有不同
### 二、rpc  相较于传统api 调用的优点，如何设计实现一个rpc
- 感觉用grpc省事一些。
- 适合内部服务调用，
- 不然每次调整接口。上下游都要调整
多一个参数，少一个参数的。版本很难控制
- 为什么选择grpc，不用restful呢？这个问题面试官可以经常问￼
- 这让我想起了树哥的话，事件驱动和命令驱动
- grpc可以长连接
还可以双向通信
- restful 设定keepalive不行吗？
- 那个还是ws
http其实可以有状态
就是up成ws
- 感觉RPC 和 HTTP 放一起比较还不太合适。RPC可以看做一个概念，HTTP 可以看做一种通信协议。RPC 可以选择基于 HTTP，也可以选择自己定制。
嗯对，很大。restful 是不是也能叫一种远程调用。
- 我自己进行rpc的定义
- grpc怎么做限流呢？需要外部提供限流吗？
- gateway 就顺便做了
- grpc支持双端流通信，如果发送端发送的数据量很大，接收端处理比较慢，会出现什么状态呢？
- 积压， 和消息队列一样
- 消息队列会削峰的，不一样
- 生产者能力强消费者能力弱
- 此削峰非彼削峰
- 消息队列都是拉取模式。削峰了。rocket kafka
比如拉了1000个。没处理完 不会在拉
- 峰值削的是写入数据库的，其实是堆积在消息队列里的
是啊，生产者能力强，消费者能力弱
消费不完，生产者还在生产
- 那grpc呢，存哪？
- 母鸡🐔 只是我的猜测，会不会积压
只是积压在哪里的问题
- 我也母鸡 。我很排斥rpc。。。哈哈
- 我当时说的是grpc会有一个缓存区，缓存区满的话，会被直接拒掉￼
- 问这种题目的意义何在
这个底层也就是http2.0
也就是tcp
![http处理.jpeg](https://upload-images.jianshu.io/upload_images/331298-2ca8bff5153dc496.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 处理不过来就超时呗
- 考察grpc双端流的通信机制吧
- 这个是http的代码。并没做什么处理
至于grpc内部有没处理 就不了解了。比较排斥。不想看
- tcp处理不过来，堵塞，丢包，触发拥塞控制？
- 会触发超时
- 超时后，这次双端流交互就结束了？
- 不至于结束
grpc本身有没有控制处理我也没看
grpc是个框架
他里面会要么自己处理这种
- 这个参数也没个注释……
- 客户端结束 服务端没有
- 有重试
![grpc重试.jpeg](https://upload-images.jianshu.io/upload_images/331298-540847787fbe41d4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)









